{"ast":null,"code":"// All the Firestore magic imports! This is where we talk to our database.\nimport { collection, addDoc, updateDoc, deleteDoc, doc, getDoc, getDocs, query, where, orderBy, serverTimestamp, limit } from 'firebase/firestore';\nimport { db } from './firebase';\n\n// ----- COMMENTS SECTION -----\n// Add a comment to a place (each place has its own lil' comments collection)\nexport const addCommentToPlace = async (placeId, commentData) => {\n  try {\n    const commentsRef = collection(db, 'places', placeId, 'comments');\n    const newComment = {\n      ...commentData,\n      createdAt: serverTimestamp()\n    };\n    return await addDoc(commentsRef, newComment);\n  } catch (error) {\n    console.error('Error adding comment:', error);\n    throw error;\n  }\n};\n\n// Get the most recent comments for a place (default 20)\nexport const getCommentsForPlace = async (placeId, maxCount = 20) => {\n  try {\n    const commentsRef = collection(db, 'places', placeId, 'comments');\n    const q = query(commentsRef, orderBy('createdAt', 'desc'), limit(maxCount));\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching comments:', error);\n    throw error;\n  }\n};\n\n// ----- PLACES SECTION -----\n// Danger zone! This deletes ALL places from the DB. Use with caution, bro.\nexport const clearAllPlaces = async () => {\n  try {\n    const placesRef = collection(db, 'places');\n    const snapshot = await getDocs(placesRef);\n    const batchDeletes = [];\n    snapshot.forEach(docSnap => {\n      batchDeletes.push(deleteDoc(doc(db, 'places', docSnap.id)));\n    });\n    await Promise.all(batchDeletes);\n    return true;\n  } catch (error) {\n    console.error('Error clearing all places:', error);\n    throw error;\n  }\n};\n\n// Add a new place to Firestore (sanitize the data first)\nexport const addPlace = async placeData => {\n  try {\n    // Remove undefined/null fields from placeData\n    const sanitizedData = Object.fromEntries(Object.entries(placeData).filter(([_, v]) => v !== undefined && v !== null));\n    const placesRef = collection(db, 'places');\n    const newPlace = {\n      ...sanitizedData,\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp()\n    };\n    // Extra debug logging\n    console.log('Attempting to add place:', newPlace);\n    const result = await addDoc(placesRef, newPlace);\n    console.log('Place added successfully:', result.id);\n    return result;\n  } catch (error) {\n    // Enhanced error logging\n    if (error && error.code && error.message) {\n      console.error(`Firestore error [${error.code}]: ${error.message}`);\n    } else {\n      console.error('Unknown error adding place:', error);\n    }\n    throw error;\n  }\n};\n\n// Get all places, sorted by name (for dropdowns, lists, etc)\nexport const getPlaces = async () => {\n  try {\n    const placesRef = collection(db, 'places');\n    const q = query(placesRef, orderBy('name', 'asc'));\n    const querySnapshot = await getDocs(q);\n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error getting places:', error);\n    throw error;\n  }\n};\n\n// Get places filtered by category (e.g., only 'food' places)\nexport const getPlacesByCategory = async category => {\n  try {\n    const placesRef = collection(db, 'places');\n    const q = query(placesRef, where('category', '==', category), orderBy('name', 'asc'));\n    const querySnapshot = await getDocs(q);\n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error getting places by category:', error);\n    throw error;\n  }\n};\n\n// ----- REPORTS SECTION -----\n// Add a new crowd report for a place (expires in 2 hours)\nexport const addReport = async reportData => {\n  try {\n    const reportsRef = collection(db, 'reports');\n    const newReport = {\n      ...reportData,\n      timestamp: serverTimestamp(),\n      expiresAt: new Date(Date.now() + 2 * 60 * 60 * 1000) // 2 hours from now\n    };\n    return await addDoc(reportsRef, newReport);\n  } catch (error) {\n    console.error('Error adding report:', error);\n    throw error;\n  }\n};\n\n// Get recent (not expired) reports for a place, newest first\nexport const getRecentReportsByPlace = async placeId => {\n  try {\n    const reportsRef = collection(db, 'reports');\n    const now = new Date();\n    const q = query(reportsRef, where('placeId', '==', placeId), where('expiresAt', '>', now), orderBy('expiresAt', 'desc'), orderBy('timestamp', 'desc'), limit(10));\n    const querySnapshot = await getDocs(q);\n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error getting recent reports:', error);\n    throw error;\n  }\n};\n\n// Get all reports made by a specific user (sorted by newest)\nexport const getUserReports = async userId => {\n  try {\n    const reportsRef = collection(db, 'reports');\n    const q = query(reportsRef, where('userId', '==', userId), orderBy('timestamp', 'desc'));\n    const querySnapshot = await getDocs(q);\n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error getting user reports:', error);\n    throw error;\n  }\n};\n\n// Delete a report by its ID (used in the dashboard)\nexport const deleteReport = async reportId => {\n  try {\n    const reportRef = doc(db, 'reports', reportId);\n    await deleteDoc(reportRef);\n  } catch (error) {\n    console.error('Error deleting report:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["collection","addDoc","updateDoc","deleteDoc","doc","getDoc","getDocs","query","where","orderBy","serverTimestamp","limit","db","addCommentToPlace","placeId","commentData","commentsRef","newComment","createdAt","error","console","getCommentsForPlace","maxCount","q","snapshot","docs","map","id","data","clearAllPlaces","placesRef","batchDeletes","forEach","docSnap","push","Promise","all","addPlace","placeData","sanitizedData","Object","fromEntries","entries","filter","_","v","undefined","newPlace","updatedAt","log","result","code","message","getPlaces","querySnapshot","getPlacesByCategory","category","addReport","reportData","reportsRef","newReport","timestamp","expiresAt","Date","now","getRecentReportsByPlace","getUserReports","userId","deleteReport","reportId","reportRef"],"sources":["C:/Users/Vihaan/Desktop/When To Visit/src/services/firestoreService.js"],"sourcesContent":["// All the Firestore magic imports! This is where we talk to our database.\nimport { \n  collection, \n  addDoc, \n  updateDoc, \n  deleteDoc, \n  doc, \n  getDoc, \n  getDocs, \n  query, \n  where, \n  orderBy, \n  serverTimestamp,\n  limit\n} from 'firebase/firestore';\nimport { db } from './firebase';\n\n// ----- COMMENTS SECTION -----\n// Add a comment to a place (each place has its own lil' comments collection)\nexport const addCommentToPlace = async (placeId, commentData) => {\n  try {\n    const commentsRef = collection(db, 'places', placeId, 'comments');\n    const newComment = {\n      ...commentData,\n      createdAt: serverTimestamp()\n    };\n    return await addDoc(commentsRef, newComment);\n  } catch (error) {\n    console.error('Error adding comment:', error);\n    throw error;\n  }\n};\n\n// Get the most recent comments for a place (default 20)\nexport const getCommentsForPlace = async (placeId, maxCount = 20) => {\n  try {\n    const commentsRef = collection(db, 'places', placeId, 'comments');\n    const q = query(commentsRef, orderBy('createdAt', 'desc'), limit(maxCount));\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n  } catch (error) {\n    console.error('Error fetching comments:', error);\n    throw error;\n  }\n};\n\n// ----- PLACES SECTION -----\n// Danger zone! This deletes ALL places from the DB. Use with caution, bro.\nexport const clearAllPlaces = async () => {\n  try {\n    const placesRef = collection(db, 'places');\n    const snapshot = await getDocs(placesRef);\n    const batchDeletes = [];\n    snapshot.forEach(docSnap => {\n      batchDeletes.push(deleteDoc(doc(db, 'places', docSnap.id)));\n    });\n    await Promise.all(batchDeletes);\n    return true;\n  } catch (error) {\n    console.error('Error clearing all places:', error);\n    throw error;\n  }\n};\n\n// Add a new place to Firestore (sanitize the data first)\nexport const addPlace = async (placeData) => {\n  try {\n    // Remove undefined/null fields from placeData\n    const sanitizedData = Object.fromEntries(\n      Object.entries(placeData).filter(([_, v]) => v !== undefined && v !== null)\n    );\n\n    const placesRef = collection(db, 'places');\n    const newPlace = {\n      ...sanitizedData,\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp()\n    };\n    // Extra debug logging\n    console.log('Attempting to add place:', newPlace);\n    const result = await addDoc(placesRef, newPlace);\n    console.log('Place added successfully:', result.id);\n    return result;\n  } catch (error) {\n    // Enhanced error logging\n    if (error && error.code && error.message) {\n      console.error(`Firestore error [${error.code}]: ${error.message}`);\n    } else {\n      console.error('Unknown error adding place:', error);\n    }\n    throw error;\n  }\n};\n\n// Get all places, sorted by name (for dropdowns, lists, etc)\nexport const getPlaces = async () => {\n  try {\n    const placesRef = collection(db, 'places');\n    const q = query(placesRef, orderBy('name', 'asc'));\n    const querySnapshot = await getDocs(q);\n    \n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error getting places:', error);\n    throw error;\n  }\n};\n\n// Get places filtered by category (e.g., only 'food' places)\nexport const getPlacesByCategory = async (category) => {\n  try {\n    const placesRef = collection(db, 'places');\n    const q = query(\n      placesRef, \n      where('category', '==', category),\n      orderBy('name', 'asc')\n    );\n    const querySnapshot = await getDocs(q);\n    \n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error getting places by category:', error);\n    throw error;\n  }\n};\n\n// ----- REPORTS SECTION -----\n// Add a new crowd report for a place (expires in 2 hours)\nexport const addReport = async (reportData) => {\n  try {\n    const reportsRef = collection(db, 'reports');\n    const newReport = {\n      ...reportData,\n      timestamp: serverTimestamp(),\n      expiresAt: new Date(Date.now() + 2 * 60 * 60 * 1000) // 2 hours from now\n    };\n    return await addDoc(reportsRef, newReport);\n  } catch (error) {\n    console.error('Error adding report:', error);\n    throw error;\n  }\n};\n\n// Get recent (not expired) reports for a place, newest first\nexport const getRecentReportsByPlace = async (placeId) => {\n  try {\n    const reportsRef = collection(db, 'reports');\n    const now = new Date();\n    \n    const q = query(\n      reportsRef,\n      where('placeId', '==', placeId),\n      where('expiresAt', '>', now),\n      orderBy('expiresAt', 'desc'),\n      orderBy('timestamp', 'desc'),\n      limit(10)\n    );\n    \n    const querySnapshot = await getDocs(q);\n    \n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error getting recent reports:', error);\n    throw error;\n  }\n};\n\n// Get all reports made by a specific user (sorted by newest)\nexport const getUserReports = async (userId) => {\n  try {\n    const reportsRef = collection(db, 'reports');\n    const q = query(\n      reportsRef,\n      where('userId', '==', userId),\n      orderBy('timestamp', 'desc')\n    );\n    \n    const querySnapshot = await getDocs(q);\n    \n    return querySnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error getting user reports:', error);\n    throw error;\n  }\n};\n\n// Delete a report by its ID (used in the dashboard)\nexport const deleteReport = async (reportId) => {\n  try {\n    const reportRef = doc(db, 'reports', reportId);\n    await deleteDoc(reportRef);\n  } catch (error) {\n    console.error('Error deleting report:', error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}